# -*- coding: utf-8 -*-
"""ZERODHAOPTIONS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-odu2RFvPC2ebGWEviQxthBfmVVQV5HR
"""

from flask import Flask, request, jsonify
from kiteconnect import KiteConnect
import pandas as pd

app = Flask(__name__)

@app.route('/option-chain', methods=['POST'])
def get_option_chain():
    data = request.json
    api_key = data["api_key"]
    access_token = data["access_token"]
    symbol = data.get("symbol", "NIFTY").upper()  # default to NIFTY
    range_limit = data.get("range", 5)  # e.g., ATM Â± 5 strikes
    step_size = data.get("step", 50)   # default step size

    kite = KiteConnect(api_key=api_key)
    kite.set_access_token(access_token)

    # Fetch instruments
    df = pd.DataFrame(kite.instruments("NFO"))

    # Filter for CE/PE of desired symbol
    opt_df = df[(df['name'] == symbol) & (df['instrument_type'].isin(['CE', 'PE']))]
    if opt_df.empty:
        return jsonify({"error": f"No option chain found for symbol: {symbol}"}), 400

    expiry = sorted(opt_df['expiry'].unique())[0]
    filtered = opt_df[opt_df['expiry'] == expiry]

    # Spot price
    try:
        spot_symbol = f"NSE:{symbol}" if symbol not in ["NIFTY", "BANKNIFTY", "FINNIFTY"] else f"NSE:{symbol} 50"
        spot = kite.ltp(spot_symbol)[spot_symbol]["last_price"]
    except Exception:
        return jsonify({"error": f"Could not fetch LTP for {symbol}"}), 400

    # Calculate strike range
    rounded_atm = round(spot / step_size) * step_size
    strikes = list(range(rounded_atm - range_limit * step_size,
                         rounded_atm + (range_limit + 1) * step_size,
                         step_size))
    filtered = filtered[filtered["strike"].isin(strikes)]

    # Get quote data
    tokens = filtered["instrument_token"].tolist()
    quote_data = kite.quote(tokens)

    rows = []
    for strike in strikes:
        ce = filtered[(filtered["strike"] == strike) & (filtered["instrument_type"] == "CE")]
        pe = filtered[(filtered["strike"] == strike) & (filtered["instrument_type"] == "PE")]
        ce_token = ce["instrument_token"].values[0] if not ce.empty else None
        pe_token = pe["instrument_token"].values[0] if not pe.empty else None
        ce_quote = quote_data.get(ce_token, {}) if ce_token else {}
        pe_quote = quote_data.get(pe_token, {}) if pe_token else {}

        rows.append({
            "Strike": strike,
            "CE Price": ce_quote.get("last_price"),
            "CE OI": ce_quote.get("oi"),
            "CE Volume": ce_quote.get("volume"),
            "CE IV": ce_quote.get("implied_volatility"),
            "PE Price": pe_quote.get("last_price"),
            "PE OI": pe_quote.get("oi"),
            "PE Volume": pe_quote.get("volume"),
            "PE IV": pe_quote.get("implied_volatility")
        })

    return jsonify({
        "symbol": symbol,
        "expiry": str(expiry),
        "spot_price": spot,
        "data": rows
    })

if __name__ == '__main__':
    app.run(debug=True)